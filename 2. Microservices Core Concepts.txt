# 2. MICROSERVICES CORE CONCEPTS
--------------------------------

* The Services
--------------
Is not about the size of the service.  Is about the operation of the service.

. The communication is always through HTTP ---> This is a powerful proposition especially for large organizations.

. REST

. GRP, GRAPHQL --> Sometimes.

. Each team in an organization can build software if they see fit, if the services are exposed via HTTP.

. Documentation in this case shouldn't be ignored.

. MICROSERVICE: Handles one set of related functions with little or no cross-domain operations.

			* DOMAIN-DRIVEN DESIGN

			* ANALOGY OF GOOD OBJECT-ORIENTED PROGRAMMING PRACTICES
			-------------------------------------------------------
				In a well-defined OOP space, a class is built to handle over one type of thing and provide all operations for that type.

				In a microservices architecture, a service operates in a well-defined domain.

			* OPERATIONS ARE DEFINED ON THE DOMAIN AS A WHOLE.

			* A DOMAIN SHOULD BE DOMAIN OPERATIONS FOCUSED.

			
* Microservice Design Antipatterns
----------------------------------
. Too fine grained. ---> THIS IS MORE COMMON.  QUICKLY THE DISTRIBUITION TASK WILL HIT YOU HARD AS THE LATENCY OF CALLS REALLY KICKS IN.

. Not fine grained enough.


------------------------------------------------------------------------------------------------------------------------------------------------------------------

* The communication dance
-------------------------
In a microservices architecture, the interservice communication can be a source of freedom for growth, but it can also be a source of great pain.

			* ALL COMMUNICATIONS BETWEEN SERVICES IN A MICROSERVICES ARCHITECTURE IS OVER HTTP USING REST-BASED SERVICES.

			* ALLOWS THE USE OF ANY CODING LANGUAGE OR FRAMEWORK THAT SUPPORTS RESTFUL SERVICES.

			* PROTOCOL-AWARE HETEROGENEOUS INTEROPERABILITY
			-----------------------------------------------
			Services are bound to a protocol and execute communication over that protocol in a way that works in a mixed or heterogeneus way.

			* THE BEAUTY OF A MICROSERVICES ARCHITECTURE IS THAT EACH TEAM MEMBER CAN BUILD THE SERVICES IN A LANGUAGE NATIVE TO THEM, AND THEN EXPOSE THE SERVICE FOR OTHERS
			TO CONSUME, USING HTTP.

			* THIS EMPHASIZES AGILITY.

			* EVERY MODERN FRAMEWORK CAN LEVERAGE REST.  THIS WAS NOT THE CASE WHEN WORKING WITH SOAP (WITH JAVA).

			* AS THE TEAMS WORK IN THEIR OWN DOMAIN AS EFFICIENTLY AS POSSIBLE, THEY DELIVER CODE QUICKER.

			* PROBLEMS CAN ARISE FROM ALL THESE NETWORK CALLS, AS EACH SERVICE CAN CALL ANY OTHER SERVICE.

			* IN THIS MODEL OF MICROSERVICES, EACH SERVICE OF CALLING ANY OTHER SERVICE IN THE SYSTEM. --> THIS MEANS ORCHESTRATION IS KEY.

			* EACH SERVICE MUST MAINTAIN A CERTAIN LEVEL OF PASSIVITY IN THEIR APIS, OR THERE IS A RISK OF SYSTEM FAILURE.

			* YOU MUST EITHER HAVE A SOLID VERSIONING STRATEGY OR MAINTAIN PERFECTLY PASSIVE APIS TO PREVENT CALLING SYSTEMS FROM FAILING WHEN YOU RELEASE A NEW VERSION OF YOUR
			API.

			* A SOLID VERSIONING STRATEGY, CONTRACT TESTING AND STRONG PASSIVITIY RULES TO PREVENT THIS FROM BECOMING A MAJOR CONCERN IN THE SYSTEM.


------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Distribution and scale
------------------------
Possibility of global distribution.

The microservices architecture model provides for a highly-scalable system.

			* EACH SERVICE IS ACCESSED OVER REMOTE NETWORK CALLS
			----------------------------------------------------
			. Regardless of being in a local or remote data center. --> You can theoretically move your services anywhere.

			. This is very expensive but solves the problem of getting infrastructure and services globally available when needed, when making the entire system globally 
			available.


* Enterprise and Internet Needs
-------------------------------
. Customer-facing applications.

. BUsiness-facing applications.

. All for day 2 growth from day 1.


			* THE ABILITY TO SCALE IS PART OF THIS ARCHITECTURAL STYLE

			* IN A MICROSERVICES ARCHITECTURE, EACH SERVICE IS INDEPENDANT OF EVERY OTHER SERVICE OR APPLICATION IN THE SYSTEM.

			* WHEN AN INDIVIDUL SERVICE COMES UNDER LOAD, IT CAN BE INDIVIDUALLY SCALED.


* Traditional Strategy of Monoliths
-----------------------------------
Scale for the busiest day, every day.

Traditionally you build your systems planning for the busiest day, every day.


* Microservice Strategy
-----------------------
Build for the average day and scale as needed.


------------------------------------------------------------------------------------------------------------------------------------------------------------------

* The dangers of latency and gridlock
-------------------------------------
Every service invocation is a remote network call.

There is latency in every single call.

As the traffic increases, the risk of latency increases.

Latency in a low-level service or any service can become exponentially exaggerated in a model where every call is remote.

It could be a catastrophic failure of the entire service.

Other path to gridlock is circular call.

			YOU NEED TO SPEND A SIGNIFICAN AMOUNT OF TIME EVALUATING HOW TO CONTROL THE NEGATIVE REACTIONS TO LATENCY.

			ONE SUCH PATTERN IS TO USE A CIRCUIT BREAKER.

------------------------------------------------------------------------------------------------------------------------------------------------------------------






		





































			



			

			



