# 2. MICROSERVICES CORE CONCEPTS
--------------------------------

* The Services
--------------
Is not about the size of the service.  Is about the operation of the service.

. The communication is always through HTTP ---> This is a powerful proposition especially for large organizations.

. REST

. GRP, GRAPHQL --> Sometimes.

. Each team in an organization can build software if they see fit, if the services are exposed via HTTP.

. Documentation in this case shouldn't be ignored.

. MICROSERVICE: Handles one set of related functions with little or no cross-domain operations.

			* DOMAIN-DRIVEN DESIGN

			* ANALOGY OF GOOD OBJECT-ORIENTED PROGRAMMING PRACTICES
			-------------------------------------------------------
				In a well-defined OOP space, a class is built to handle over one type of thing and provide all operations for that type.

				In a microservices architecture, a service operates in a well-defined domain.

			* OPERATIONS ARE DEFINED ON THE DOMAIN AS A WHOLE.

			* A DOMAIN SHOULD BE DOMAIN OPERATIONS FOCUSED.

			
* Microservice Design Antipatterns
----------------------------------
. Too fine grained. ---> THIS IS MORE COMMON.  QUICKLY THE DISTRIBUITION TASK WILL HIT YOU HARD AS THE LATENCY OF CALLS REALLY KICKS IN.

. Not fine grained enough.


------------------------------------------------------------------------------------------------------------------------------------------------------------------

* The communication dance
-------------------------
In a microservices architecture, the interservice communication can be a source of freedom for growth, but it can also be a source of great pain.

			* ALL COMMUNICATIONS BETWEEN SERVICES IN A MICROSERVICES ARCHITECTURE IS OVER HTTP USING REST-BASED SERVICES.

			* ALLOWS THE USE OF ANY CODING LANGUAGE OR FRAMEWORK THAT SUPPORTS RESTFUL SERVICES.

			* PROTOCOL-AWARE HETEROGENEOUS INTEROPERABILITY
			-----------------------------------------------
			Services are bound to a protocol and execute communication over that protocol in a way that works in a mixed or heterogeneus way.

			* THE BEAUTY OF A MICROSERVICES ARCHITECTURE IS THAT EACH TEAM MEMBER CAN BUILD THE SERVICES IN A LANGUAGE NATIVE TO THEM, AND THEN EXPOSE THE SERVICE FOR OTHERS
			TO CONSUME, USING HTTP.

			* THIS EMPHASIZES AGILITY.

			* EVERY MODERN FRAMEWORK CAN LEVERAGE REST.  THIS WAS NOT THE CASE WHEN WORKING WITH SOAP (WITH JAVA).

			* AS THE TEAMS WORK IN THEIR OWN DOMAIN AS EFFICIENTLY AS POSSIBLE, THEY DELIVER CODE QUICKER.

			* PROBLEMS CAN ARISE FROM ALL THESE NETWORK CALLS, AS EACH SERVICE CAN CALL ANY OTHER SERVICE.

			* IN THIS MODEL OF MICROSERVICES, EACH SERVICE OF CALLING ANY OTHER SERVICE IN THE SYSTEM. --> THIS MEANS ORCHESTRATION IS KEY.

			* EACH SERVICE MUST MAINTAIN A CERTAIN LEVEL OF PASSIVITY IN THEIR APIS, OR THERE IS A RISK OF SYSTEM FAILURE.

			* YOU MUST EITHER HAVE A SOLID VERSIONING STRATEGY OR MAINTAIN PERFECTLY PASSIVE APIS TO PREVENT CALLING SYSTEMS FROM FAILING WHEN YOU RELEASE A NEW VERSION OF YOUR
			API.

			* A SOLID VERSIONING STRATEGY, CONTRACT TESTING AND STRONG PASSIVITIY RULES TO PREVENT THIS FROM BECOMING A MAJOR CONCERN IN THE SYSTEM.


------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Distribution and scale
------------------------
Possibility of global distribution.

The microservices architecture model provides for a highly-scalable system.

			* EACH SERVICE IS ACCESSED OVER REMOTE NETWORK CALLS
			----------------------------------------------------
			. Regardless of being in a local or remote data center. --> You can theoretically move your services anywhere.

			. This is very expensive but solves the problem of getting infrastructure and services globally available when needed, when making the entire system globally 
			available.


* Enterprise and Internet Needs
-------------------------------
. Customer-facing applications.

. BUsiness-facing applications.

. All for day 2 growth from day 1.


			* THE ABILITY TO SCALE IS PART OF THIS ARCHITECTURAL STYLE

			* IN A MICROSERVICES ARCHITECTURE, EACH SERVICE IS INDEPENDANT OF EVERY OTHER SERVICE OR APPLICATION IN THE SYSTEM.

			* WHEN AN INDIVIDUL SERVICE COMES UNDER LOAD, IT CAN BE INDIVIDUALLY SCALED.


* Traditional Strategy of Monoliths
-----------------------------------
Scale for the busiest day, every day.

Traditionally you build your systems planning for the busiest day, every day.


* Microservice Strategy
-----------------------
Build for the average day and scale as needed.


------------------------------------------------------------------------------------------------------------------------------------------------------------------

* The dangers of latency and gridlock
-------------------------------------
Every service invocation is a remote network call.

There is latency in every single call.

As the traffic increases, the risk of latency increases.

Latency in a low-level service or any service can become exponentially exaggerated in a model where every call is remote.

It could be a catastrophic failure of the entire service.

Other path to gridlock is circular call.

			YOU NEED TO SPEND A SIGNIFICAN AMOUNT OF TIME EVALUATING HOW TO CONTROL THE NEGATIVE REACTIONS TO LATENCY.

			ONE SUCH PATTERN IS TO USE A CIRCUIT BREAKER.

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Bounded context
-----------------
When deciding the size of the microservices, one common practice is leveraging DOMAIN DRIVEN DESIGN.

Another common practice is to focus on the bounded context when decomposing a large multi-domain system into individual services.


* The Core Concept
------------------
. Investigate the working system.

. Determine the domains.

. Break services up accordingly.


			* MOST OF THE EARLY MISTAKES IN MIGRATING AN EXISTING MONOLITH INTO A MICROSERVICES ARCHITECTURE COMES FROM EITHER MAKING YOUR SERVICES TOO GRANULAR OR NOT 
			GRANULAR ENOUGH.

			* FIND THE GRANULATIRY SWEET SPOT BY LEVERAGING DOMAIN-DRIVEN DESIGN.

			* ANALYZE THE TRAFFIC PATTERNS IN YOUR CODE AND DEVELOP REAL-WORLD USE CASES.

			* PART OF THE GOAL IN BUILDING ON YOUR BOUNDED CONTEXT IS TO REDUCE YOUR CROSSED DOMAIN CALLS WHEN APPROPIATE.

			* EXAMPLE
			---------
			You have a customer domain that is fairly well-defined, but you also have a user domain for your login information. As you look at traffic patterns, you note
			that every time your user domain is called, it calls your customer domain.

			This is a good argument to put both of these domains into a single-bounded context, but its necessary to think a little deeper:

				. What if only 1% of othe calls to the customer domain, come from the user domain.
				. There is data in your user domain that needs to be secured in a different manner.

			These may be sufficient arguments to separate them into different bounded contexts.

			* BOUNDED CONTEXT MATTERS A LOT BECAUSE OF LATENCY.  

			* LATENCY IS ONE OF THE BIGGEST PAIN POINTS IN MICROSERVICES.

			* THERE'S FRANKLY NO NEED TO MAKE EXTRA CALLS WHEN THEY MAKE ZERO SENSE.

			* BY EVALUATING THE DOMAINS, AND BUILDING STRONG BOUNDED CONTEXT, YOU CAN REDUCE THE NUMBER OF CALLS MADE IN YOUR SYSTEM AS A WHOLE.

			
STRONG CONTRACST AND WELL-DEFINED BOUNDARIES ALLOW FOR SELF-DISCOVERY.

BECAUSE YOU HAVE TAKEN THE TIME TO BUILD OUT THESE DOMAINS AND STRUCTURE THEM PRECISELY, A CONSUMER OF A SERVICE ON YOUR SYSTEM, SHOULD BE ABLE TO DETERMINE THE CORRECT LOCATION TO SEARCH
FOR THE SERVICES THAT THEY NEED TO CONSUME.

THIS PROCESS DOESN'T ONLY IMPROVE THE PERFORMANCE OF THE SYSTEM AS A WHOLE, BUT ALSO IMPROVES AGILITLY.

------------------------------------------------------------------------------------------------------------------------------------------------------------------





			








		





































			



			

			



