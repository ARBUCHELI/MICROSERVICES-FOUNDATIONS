# 2. MICROSERVICES CORE CONCEPTS
--------------------------------

* The Services
--------------
Is not about the size of the service.  Is about the operation of the service.

. The communication is always through HTTP ---> This is a powerful proposition especially for large organizations.

. REST

. GRP, GRAPHQL --> Sometimes.

. Each team in an organization can build software if they see fit, if the services are exposed via HTTP.

. Documentation in this case shouldn't be ignored.

. MICROSERVICE: Handles one set of related functions with little or no cross-domain operations.

			* DOMAIN-DRIVEN DESIGN

			* ANALOGY OF GOOD OBJECT-ORIENTED PROGRAMMING PRACTICES
			-------------------------------------------------------
				In a well-defined OOP space, a class is built to handle over one type of thing and provide all operations for that type.

				In a microservices architecture, a service operates in a well-defined domain.

			* OPERATIONS ARE DEFINED ON THE DOMAIN AS A WHOLE.

			* A DOMAIN SHOULD BE DOMAIN OPERATIONS FOCUSED.

			
* Microservice Design Antipatterns
----------------------------------
. Too fine grained. ---> THIS IS MORE COMMON.  QUICKLY THE DISTRIBUITION TASK WILL HIT YOU HARD AS THE LATENCY OF CALLS REALLY KICKS IN.

. Not fine grained enough.


------------------------------------------------------------------------------------------------------------------------------------------------------------------

* The communication dance
-------------------------
In a microservices architecture, the interservice communication can be a source of freedom for growth, but it can also be a source of great pain.

			* ALL COMMUNICATIONS BETWEEN SERVICES IN A MICROSERVICES ARCHITECTURE IS OVER HTTP USING REST-BASED SERVICES.

			* ALLOWS THE USE OF ANY CODING LANGUAGE OR FRAMEWORK THAT SUPPORTS RESTFUL SERVICES.

			* PROTOCOL-AWARE HETEROGENEOUS INTEROPERABILITY
			-----------------------------------------------
			Services are bound to a protocol and execute communication over that protocol in a way that works in a mixed or heterogeneus way.

			* THE BEAUTY OF A MICROSERVICES ARCHITECTURE IS THAT EACH TEAM MEMBER CAN BUILD THE SERVICES IN A LANGUAGE NATIVE TO THEM, AND THEN EXPOSE THE SERVICE FOR OTHERS
			TO CONSUME, USING HTTP.

			* THIS EMPHASIZES AGILITY.

			* EVERY MODERN FRAMEWORK CAN LEVERAGE REST.  THIS WAS NOT THE CASE WHEN WORKING WITH SOAP (WITH JAVA).

			* AS THE TEAMS WORK IN THEIR OWN DOMAIN AS EFFICIENTLY AS POSSIBLE, THEY DELIVER CODE QUICKER.

			* PROBLEMS CAN ARISE FROM ALL THESE NETWORK CALLS, AS EACH SERVICE CAN CALL ANY OTHER SERVICE.

			* IN THIS MODEL OF MICROSERVICES, EACH SERVICE OF CALLING ANY OTHER SERVICE IN THE SYSTEM. --> THIS MEANS ORCHESTRATION IS KEY.

			* EACH SERVICE MUST MAINTAIN A CERTAIN LEVEL OF PASSIVITY IN THEIR APIS, OR THERE IS A RISK OF SYSTEM FAILURE.

			* YOU MUST EITHER HAVE A SOLID VERSIONING STRATEGY OR MAINTAIN PERFECTLY PASSIVE APIS TO PREVENT CALLING SYSTEMS FROM FAILING WHEN YOU RELEASE A NEW VERSION OF YOUR
			API.

			* A SOLID VERSIONING STRATEGY, CONTRACT TESTING AND STRONG PASSIVITIY RULES TO PREVENT THIS FROM BECOMING A MAJOR CONCERN IN THE SYSTEM.


------------------------------------------------------------------------------------------------------------------------------------------------------------------



			



			

			



